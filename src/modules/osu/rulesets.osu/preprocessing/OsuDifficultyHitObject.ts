import DifficultyHitObject from '../../base/rulesets/difficulty/preprocessing/DIfficultyHitObject';
import type OsuHitObject from '../objects/OsuHitObject';

export default class OsuDifficultyHitObject extends DifficultyHitObject {
  private static normalised_radius = 50; // Change radius to 50 to make 100 the diameter. Easier for mental maths.
  private static min_delta_time = 25;
  private static maximum_slider_radius = this.normalised_radius * 2.4;
  private static assumed_slider_radius = this.normalised_radius * 1.8;

  public declare baseObject: OsuHitObject;

  public declare lastObject: OsuHitObject;

  public lastLastObject: OsuHitObject;

  /**
   * The aim strain generated by the hitobject if sliders are considered.
   */
  public aimStrainWithSliders = 0;

  /**
   * The aim strain generated by the hitobject if sliders are not considered.
   */
  public aimStrainWithoutSliders = 0;

  /**
   * The tap strain generated by the hitobject.
   *
   * This is also used for osu!standard as opposed to "speed strain".
   */
  public tapStrain = 0;

  /**
   * The tap strain generated by the hitobject if `strainTime` isn't modified by
   * OD. This is used in three-finger detection.
   */
  public originalTapStrain = 0;

  /**
   * The rhythm multiplier generated by the hitobject. This is used to alter tap strain.
   */
  public rhythmMultiplier = 0;

  /**
   * The rhythm strain generated by the hitobject.
   */
  public rhythmStrain = 0;

  /**
   * The flashlight strain generated by the hitobject.
   */
  public flashlightStrain = 0;

  /**
   * The normalized distance from the "lazy" end position of the previous hitobject to the start position of this hitobject.
   *
   * The "lazy" end position is the position at which the cursor ends up if the previous hitobject is followed with as minimal movement as possible (i.e. on the edge of slider follow circles).
   */
  public lazyJumpDistance = 0;

  /**
   * The normalized shortest distance to consider for a jump between the previous hitobject and this hitobject.
   *
   * This is bounded from above by `lazyJumpDistance`, and is smaller than the former if a more natural path is able to be taken through the previous hitobject.
   *
   * Suppose a linear slider - circle pattern. Following the slider lazily (see: `lazyJumpDistance`) will result in underestimating the true end position of the slider as being closer towards the start position.
   * As a result, `lazyJumpDistance` overestimates the jump distance because the player is able to take a more natural path by following through the slider to its end,
   * such that the jump is felt as only starting from the slider's true end position.
   *
   * Now consider a slider - circle pattern where the circle is stacked along the path inside the slider.
   * In this case, the lazy end position correctly estimates the true end position of the slider and provides the more natural movement path.
   */
  public minimumJumpDistance = 0;

  /**
   * The time taken to travel through `minimumJumpDistance`, with a minimum value of 25ms.
   */
  public minimumJumpTime = 0;

  /**
   * The normalized distance between the start and end position of this hitobject.
   */
  public travelDistance = 0;

  /**
   * The time taken to travel through `travelDistance`, with a minimum value of 25ms for a non-zero distance.
   */
  public travelTime = 0;

  /**
   * Angle the player has to take to hit this hitobject.
   *
   * Calculated as the angle between the circles (current-2, current-1, current).
   */
  public angle?: number;

  /**
   * The amount of milliseconds elapsed since the start time of the previous hitobject, with a minimum of 25ms.
   */
  public strainTime = 0;

  public constructor(
    hitObject: OsuHitObject,
    lastLastObject: OsuHitObject,
    lastObject: OsuHitObject,
    clockRate: number
  ) {
    super(hitObject, lastObject, clockRate);
    this.lastLastObject = lastLastObject;

    this.strainTime = Math.max(
      this.deltaTime,
      OsuDifficultyHitObject.min_delta_time
    );
  }

  private setDistances(clockRate: number): void {
    // TODO
  }
}
